<html>


<body>
    <div> this overview </div>
    <ul>
        <li>step by step</li>
        <li>day day up</li>
        <li>3.0.1 why we need this ?</li>
        <li> 3.0.2 how to apply this? </li>      
    </ul>
    <script>
        // 1.0.0 with or without strict mode when the default value is winodw or undefined  
        function f(){
        'use strict'
        console.log(this)
        }
        f.call(1) // 数字1 
        
        // 1.0.1
        function f(){
        console.log(this)
        }
        f.call(1) // 对象1 
        
        //1.0.2
        function f(){
        console.log(this)
        }
        f.call() // window 
        
        //1.0.3
        function f(){
        'use strict'
        console.log(this)
        }
        f.call() // undefined 
        
        //1.0.4
        function f1() {
        console.log(" without strict" + this);
        }
        // 返回false，因为"this"指向全局对象，"!this"就是false
        f1();
        
        
        function f2() {
            "use strict";
            console.log(" with strict " + this);
        }
        f2();
        // 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。
        // without new 
        
        
        
        function f3() {
            "use strict";
            this.a = 1;
        };
        f3();  
        // 参考：http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html        
        
        
      
        
        
        // 2.0 Explicit Binding: funciton with call(),apply() and bind()
        
        // 2.0.1 call method 的第一个参数 是什么？
        function func(arg1, arg2) {
            console.log(this);
            console.log(arg1);
            console.log(arg2);
        }

        func.call("a", "b", "c");
        func.call("a", ["b", "c"]);

        var obj = {
            method: function() {
                console.log(this === obj)
            }
        }
        obj.method.call(obj);
        
        
        // 2.0.2 
            function foo() {
            console.log(this.a);
        }
        var obj = {
            a: 2
        }
        var bar = function() {
            foo.call(obj);// hard binding 
        }
        bar.call(window);
        
        setTimeout(bar,100);        
        
        
        //2.0.3 
        function foo(something){
        console.log(this.a,something);
        return this.a + something;
}
        var obj = {
        a:2
}
        var bar = function(){
        return foo.apply(obj,arguments);
            
}
        
        var b  = bar(3);
        console.log(b);  
        
        
        // 2.0.4 
        function foo(something) {
        console.log(this.a, something);
        return this.a + something;
        }
        var obj = {
            a: 2
        }
        var bar = foo.bind(obj);
        var b = bar(3);
        console.log(b);
        
        
        // 2.0.5 
        function foo(el) {
        console.log(el, this.id)
        }
        var obj = {
            id: "test"
        };
        [1, 2, 3].forEach(foo, obj);   
        
        
       
        // 2.0.6
        var obj = {
            foo: function() {
                console.log("2.0 foo 被 obj invoke  " + this)
            }
        }
        obj.foo.call(obj);            
        

        
        // 2.0.7 
        var test = {
            Test: function() {
                console.log("3.0 和 4.0 分别是 Test 被 test invoke  " + this)
            }
        }
        var HelloTest = test.Test;
        test.Test.call(test);
        HelloTest.call(window);
        
        
        
        // 2.0.8 
        function hello(thing) {
            console.log("Hello " + thing);
        }

        // this:
        hello("world");

        // desugars to:
        hello.call(window, "test OKay by setting  this  to window");
        // only when using strict mode 
        hello.call(undefined, "world by setting this to undefined  ");
        
        
        
        



        // 3.0 with new 

        var savedThis;
        function Constr() {
            savedThis = this;
            console.log(this);
        }

        var inst = new Constr();
        console.log(savedThis === inst);
        
        
        // 4.0 without new  
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        var p = Point(7, 5);
        console.log(p === undefined);
        console.log(x);
        console.log(y);
        //  apply strict mode to have a warning 
      
       

    

        // 5.0  shadowing  this   or   Implicit Binding and lost  
        // 5.0.1 不能直接把 object method 当作 function 来调用  except object method  === function 
        
        var obj = {
            name: 'Jane',
            friends: ['Tarzan', 'Cheeta'],
            loop: function() {
                'use strict';
                this.friends.forEach(
                    function(friend) {
                        console.log(this.name + ' knows ' + friend);
                    }
                );
            }
        };
        // obj.loop(); 
        // TypeError: Cannot read property 'name' of undefined
        
        
        var obj = {
            name: 'hello world ',
            friends: ['test hello world']
        }
        obj.loop = function() {
                this.friends.forEach(
                    function(friend) {
                        console.log(this === window);
                    });
        }
        obj.loop();
        
        // 5.0.2
        function callIt(func) {
            func();
        }
        var Counter = {
            count: 0,
            inc: function() {
                this.count++;
            }
        }
        //callIt(Counter.inc)();
        // didnot work out Because the this in counter inc  is set to window object        
           
        // 5.0.3
        // obj.foo 相当于是被 window 这个object call  所以是隐式绑定 
        function foo() {
          console.log(this.a);
        }

        function doFoo(fn) {
           
            fn(); 
        }
        
        var obj = {
            a: 2,
            foo: foo
        };
        
        var a = "oops, global"; 
        doFoo( obj.foo ); //oops, global
                
        

        
        // 6.0 default  new   Implicit   Explicit which one has  lowest priority ? 
        // 6.0.1 defalut:  lowest priority 
        // 6.0.1 Implicit   Explicit    which one has higher proority? 
        //  Explicit  win 
        
        function foo() {
            console.log(this.a);
        }
        var obj1 = {
            a: 2,
            foo: foo
        };
        var obj2 = {
            a: 3,
            foo: foo
        };
        obj1.foo();
        obj2.foo();
        
        obj1.foo.call(obj2);
        obj2.foo.call(obj1);
        
        // 6.0.2 new and Implicit  which one has lowest priority ?
        //new win 
        function foo(something) {
        this.a = something;
        
        }
        
        var obj1 = {
        foo: foo
};
        var obj2 = {};
        
        obj1.foo(2);
        console.log(obj1.a);
        
        obj1.foo.call(obj2,3);
        console.log(obj2.a);
        
        var bar = new obj1.foo(4);
        console.log(obj1.a);
        console.log(bar.a); 
        
        //  6.0.3  Explicit new which one has lowest priority
        //  not 100% confirm : Explicit win
        function foo(something) {
            this.a = something;
        }
        var obj1 = {};
        var bar = foo.bind(obj1);
        bar(2);
        console.log(obj1.a);
        
        var baz= new bar(3);
        console.log(obj1.a);
        console.log(baz.a);  
        
    
      
        
        // 7.0 例外 
        //7.0.1 没有需要传的对象 但仍然需要一个占位符 
          function foo(a, b) {
          console.log("a:" + a + "b:" + b);
        }

        foo.apply(null,[2, 3]);  
        // 7.0.1.1 使用占位符之后 this 一不小心被绑到了window 怎么办？ 引入DMZ 
          function foo(a, b) {
          console.log("a:" + a + "b:" + b);
        }
         function foo(a, b) {
         console.log("a:" + a + "b:" + b);
        }
        var empty = Object.create(null); // object.create 不会创建object.prototype
        foo.apply(empty,[2,3]);        
        //7.0.2 目标函数 被调用 使用默认绑定
           function foo() {
           console.log(this.a);
        }
        var a = 2;
        var o = {
        a:3,foo: foo
};
        var p = {a: 4};
        o.foo(o);
        (p.foo = o.foo)();        
        //7.0.3   softbind 
        
        
       
        
        
        
        
        
        
        
        
     </script>
</body>

</html>
