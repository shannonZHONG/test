<html>


<body>
    <div> this overview </div>
    <ul>
        <li></li>
        <li>/li>
        <li>3.0.1 why we need this ?</li>
        <li> 3.0.2 how to apply this? </li>      
    </ul>
    <script>
        // 1.0.0 with or without strict mode when the default value is winodw or undefined  
        function f(){
        'use strict'
        console.log(this)
        }
        f.call(1) // 数字1 
        
        // 1.0.1
        function f(){
        console.log(this)
        }
        f.call(1) // 对象1 
        
        //1.0.2
        function f(){
        console.log(this)
        }
        f.call() // window 
        f()// window
        
        //1.0.3
        function f(){
        'use strict'
        console.log(this)
        }
        f.call() // undefined
        f() // undefined 
              
        
        // 2.0 Explicit Binding: funciton with call(),apply() and bind()
        
        // 2.0.1 call method 的第一个参数 是什么？
        var obj = {
            method: function() {
                console.log(this === obj)
            }
        }
        obj.method.call(obj);
        
        
        
        
       
        

        
        
  
  
        
        
       
       
        

        


    
        
   
        
        
      
        
        
        
       
        
          
                
        
        
        
        
        

      

    

        // 5.0  shadowing  this   or   Implicit Binding and lost  
         
        // 5.0.1  what happens if we attach is to the object dynamically  
        var obj = {
            name: 'Jane',
            friends: ['Tarzan', 'Cheeta'],
            loop: function() {
                'use strict';
                this.friends.forEach(
                    function(friend) {
                        console.log(this.name + ' knows ' + friend);
                    }
                );
            }
        };
        // obj.loop(); 
        // TypeError: Cannot read property 'name' of undefined
     
        
        
        var obj = {
            name: 'hello world ',
            friends: ['test hello world']
        }
        obj.loop = function() {
                this.friends.forEach(
                    function(friend) {
                        console.log(this === window);
                    });
        }
        obj.loop();
        
        
        
        Day = {
            whatDay: "monday",
            test: function(thing) {
                console.log(this + " is " + thing);
            }
        };

        Day.test.call(Day, "sunnyDay")   
        
        
        
        // 5.0.2
        function callIt(func) {
            func();
        }
        var Counter = {
            count: 0,
            inc: function() {
                this.count++;
            }
        }
        //callIt(Counter.inc)();
        // didnot work out Because the this in counter inc  is set to window object        
           
        // 5.0.3
        // obj.foo 相当于是被 window 这个object call  所以是隐式绑定 
        function foo() {
          console.log(this.a);
        }

        function doFoo(fn) {
           
            fn(); 
        }
        
        var obj = {
            a: 2,
            foo: foo
        };
        
        var a = "oops, global"; 
        doFoo( obj.foo ); //oops, global
                
        

        
        // 6.0 default  new   Implicit   Explicit which one has  lowest priority ? 
        // 6.0.1 defalut:  lowest priority 
        // 6.0.1 Implicit   Explicit    which one has higher proority? 
        //  Explicit  win 
        
        function foo() {
            console.log(this.a);
        }
        var obj1 = {
            a: 2,
            foo: foo
        };
        var obj2 = {
            a: 3,
            foo: foo
        };
        obj1.foo();
        obj2.foo();
        
        obj1.foo.call(obj2);
        obj2.foo.call(obj1);
        
        // 6.0.2 new and Implicit  which one has lowest priority ?
        //new win 
        function foo(something) {
        this.a = something;
        
        }
        
        var obj1 = {
        foo: foo
};
        var obj2 = {};
        
        obj1.foo(2);
        console.log(obj1.a);
        
        obj1.foo.call(obj2,3);
        console.log(obj2.a);
        
        var bar = new obj1.foo(4);
        console.log(obj1.a);
        console.log(bar.a); 
        
        //  6.0.3  Explicit new which one has lowest priority
        //  not 100% confirm : Explicit win
        function foo(something) {
            this.a = something;
        }
        var obj1 = {};
        var bar = foo.bind(obj1);
        bar(2);
        console.log(obj1.a);
        
        var baz= new bar(3);
        console.log(obj1.a);
        console.log(baz.a);  
        
    
      
        
        // 7.0 例外 
        //7.0.1 没有需要传的对象 但仍然需要一个占位符 
          function foo(a, b) {
          console.log("a:" + a + "b:" + b);
        }

        foo.apply(null,[2, 3]);  
        
        // 7.0.1.1 使用占位符之后 this 一不小心被绑到了window 怎么办？ 引入DMZ 
          function foo(a, b) {
          console.log("a:" + a + "b:" + b);
        }
         function foo(a, b) {
         console.log("a:" + a + "b:" + b);
        }
        var empty = Object.create(null); // object.create 不会创建object.prototype
        foo.apply(empty,[2,3]);   
        
        //7.0.2 目标函数 被调用 使用默认绑定
           function foo() {
           console.log(this.a);
        }
        var a = 2;
        var o = {
        a:3,foo: foo
};
        var p = {a: 4};
        o.foo(o);
        (p.foo = o.foo)();        
        
        
        
     
        
        
        
        
        
        
        
     </script>
</body>

</html>
