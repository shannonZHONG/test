### 2.0.1 execution context（执行环境/执行上下文) 
2.0.1.0 why we need exection context? <br>
2.0.1.1 what type of exection context?<br>
2.0.1.2 else <br>


### 2.0.2 scope and types 
2.0.2.0 what is scope <br>
2.0.2.1 type of scope <br>

### 2.0.3 Scopes Vs context 



### 2.0.4 scope chain<br>
2.0.4.1 树型结构<br>
2.0.4.2 例题一：<br> 

``` 
            var a = 1;
            function f1() {
            var a = 2;
            f2.call(window);
            console.log("f1 Scope:" + a);

            function f2() {
                var a = 3;
                console.log("f2 Scope: " + a);

            }
        }
        f1.call(window);
        console.log("window Scope:" + a);

```
例题二：<br>

``` 
  var a = 1;

        function f1() {
            a = 3;// ??????? 多注意 没有var 
            f2.call(window);
            console.log("funcion1:" + a);

            function f2() {
                var a = 4;
                console.log("function2:" + a)
            }
        }
        f1.call(window);
        console.log("window:" + a);

``` 

例题三：<br>
```   
        var foo = 1;

        function bar() {
            if (!foo) {
                var foo = 10;
            }
            console.log(foo)
        }
        bar();
        
 ``` 
 
例题四：<br>


 ``` 
        var a = 1;

        function b() {
            a = 10;
            return;

            function a() {}

        }
        b();
        console.log(a); 
 ``` 
 

例题五：<br>

```
 var a = 1;

        function f1() {
            f2.call(window);
            console.log(a);
            var a = 2;

            function f2() {
                var a = 3;
                console.log(a);
            }
        }
        f1.call(window);
        console.log(a);

``` 

例题六：<br>

```
        var a = 1;

        function f1() {
            console.log(a);  
            var a = 2;
            f4.call(window);

        }

        function f4() {
            console.log(a); 
        }
        f1.call(window);
        console.log(a);

``` 



 例题七：<br>
 ```
  var a = 1;

        function f1() {
            console.log(a);
            var a = 2;
            f4.call(window);

        }

        function f4() {
            console.log(a);
        }
        
        a = 2;
        f1.call(window);
        console.log(a);

``` 
 
 
 
 例题八：<br>
 ```
 var i = 0;
        var f = function() {
            var j = 0;
            console.log(i);

        }
        f();
        console.log(j);
``` 
 
 例题九: <br>
```
     var f = function() {
            i = 0;
            var j = 0;

        }
        f();
        console.log(i);
        console.log(j);

``` 

 
 例题十：<br>
 ```
if(true){
 var i = 0;
}
console.log(i);

``` 
 
 例题十一：<br>
 ```
for (var i = 0; i<10; i++){}
console.log(i);
``` 

 例题十二：<br>
 ```
function f(){
    return 1
}
a = f 
console.log(a); // 函数 f 

```  

例题十三：<br>
 ```
 没有独立的作用域   
 var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  liList[i].onclick = function(){
    alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5
  }
}
 
 ```
### 2.0.5 closure <br>
2.0.5.0「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。<br>
或者说 
闭包是一个函数.<br>
一个什么样的函数?<br>
有权访问另一个函数作用域中的变量的函数<br>

这是关于闭包最简单最直接的一个🌰：<br>
 ```
var local = "变量";
        function foo() {
            console.log(local);
        }
        foo.call(window);
 ```
 
 
2.0.5.1这个🌰说明:<br> 
object1 object2 中的 propertyName 是访问外部函数createComparisonFunction 得来的<br>
为什么createComparisonFunction 都执行完了，但是内部匿名函数还是可以访问它的参数？<br>
从作用域角度解释：<br>
内部匿名函数的作用域包含了外部函数createComparisonFunction的作用域<br>


从作用域展开解释:<br>
EC：每次当控制器转到ECMAScript可执行代码的时候，即会进入到一个执行上下文。<br>
标准规范没有从技术实现的角度定义EC的准确类型和结构，这应该是具体实现ECMAScript引擎时要考虑的问题。<br>
执行环境有global EC 和 function EC 之分<br>
只有一个globbal EC 当js script 被 执行时；<br>
新的function EC当一个function 被执行时；<br>
每次进入一个新EC，都会创建一个用于搜索变量和函数的作用域链<br>
变量和函数存放在哪里?<br>
EC 有两个属性<br>
存在变量对象对于global来说,存在活动对象对于function来说<br>
about scope<br>
EC 最了解scope<br>
函数的local scope 不仅可以访问自己的变量 还可以访问包含父环境的，甚至访问到global<br>
但是<br>
倒过来就不可以了<br>

所以 连起来就是, when a function is called,the EC and scope chain will be created. next,arguments and ao will be created too.

  ```
 function createComparisonFunction(propertyName) {
            return function(object1, object2) {
                var value1 = object1[propertyName];
                var value2 = object2[propertyName];

                if (value1 < value2) {
                    return -1;
                } else if (value1 > value2) {
                    return 1;
                } else {
                    return 0;
                }

            };
        }

 ```
 
2.0.5.2一个🌰说明:作用域链的本质是什么?<br>
全局环境的变量对象始终存在;<br>
local context variable object(局部环境变量对象)，take a example of function compare , local Context varaible object only <br>
存在 when function is being executed<br>


一个函数从被你写下之后。发生了什么?<br>
phase 1<br>
当function compare 被写下来时（is defined),scope chain 被创建了 and global context varaible object<br> 
也是在phase 1注入到这个函数  的[scope]属性 <br>
phase 2<br>
当function 被call 时,EC 被创建了 and scope chian去复制在[scope]里面的everything <br>
phase 3<br>
ao(like vo)被创建了 and push ao into scope chian <br>
again,take a example of function compare<br>
此时，function compare EC 有两个objects and 两个objects 同时也和scope chian 联系起来<br>
but how does the scope chian and objects  link to each others?<br>
scope chian is a list pointers to objects and DOES NOT PYSICALLY CONTAIN THE OBJECTS<br>

一旦这个function被执行完毕, the local ao will be destroyed , 只有global context variable object 才留下来.
但是闭包就不符合这个规律<br>


 ``` 
    function compare(value1, value2) {
            if (value1 < value2) {
                return -1;
            } else if (value1 > value2) {
                return 1;
            } else {
                return 0;
            }
        }

        var result = compare(5, 10);
        console.log(result); 
 ```
 
 2.0.5.3再来一个🌰说明:当外部函数消亡之后，为什么它的参数还可以被其他函数引用<br>
 外部函数的活动对象不会被销毁,因为匿名函数还是在引用这个活动对象<br>
 只要是在引用，就不会被当作垃圾收走<br>
 
 2.0.5.4再来一个🌰说明:闭包虽然是作用域的亲儿子，但是也有副作用，有副作用也不可怕，因为我们有💊可治<br>
 副作用:由于闭包会携带包含它的函数的作用域,因此会比其他函数占用更多的内存.<br>
       同时,正是由于闭包引用了太多所以闭包只能取得包含函数中的任何变量的最后一个值.<br>

  ``` 
 function createFunction() {
            var result = new Array();
            for (var i = 0; i < 10; i++) {
                result[i] = function() {
                    return i;
                }
            }
            return result;
        }
        var apple = createFunction();
        console.log(apple); 

 ```
 💊：<br>
 第一：函数的参数是按值传递的，将变量i的值传给num<br>
 第二：在第二层函数（匿名函数）中又添加一个闭包,每个函数都有自己num变量的一个副本<br>
 ``` 
   function createFunction() {
            var result = new Array();
            for (var i = 0; i < 10; i++) {
                result[i] = function(num) {
                    return function() {
                        return num;
                    }
                }(i);
            }
            return result;
        }
        var apple = createFunction();
        console.log(apple);
 
   
```  
 
2.0.5.5 闭包的目的：<br>
隐藏变量<br>
如果不把local 放在 function foo 里面  local 就成glocal value<br> 
 
  ``` 
    function foo() {
            var local = 1;

            function bar() {
                local++;
                console.log(local);
                return local;
            }
            return bar;
        }

        var func = foo();
        func();  
  ```
2.0.5.5.1 只有闭包这一个方法创造出私有变量吗？或者说闭包垄断了创造似有变量吗？<br>
no<br>

  
### 2.0.6why we need let?<br>
2.0.1 在原来没有let的时光里，是怎么搞出一个块级作用域的?<br>
IIFE<br>
IIFE的使用注意：<br>
函数的值不能直接替代函数名，会导致错误。
因为函数声明不能直接跟圆括号,要将函数声明转换成函数表达式，只需要添加一个圆括号<br>

```
(function(){})();

```
在匿名函数中定义的任何变量,都会在执行结束时被撤销<br>
因此变量i是能在循环中使用，使用后被撤销<br>

```
 function outPutNumbers(count) {
            (function() {
                for (var i = 0; i < count; i++) {
                    alert(i);
                }
            })();
            alert(i);
        }
 var test = outPutNumbers(3);      
```

### 2.0.7 垃圾回收<br>
2.0.7.1 如果一个对象没有被引用，它就是垃圾<br>
``` 
var a = { name:'a'};
var b = {name:'b'};
a = b;

 ```
2.0.7.2 内存泄漏


 
